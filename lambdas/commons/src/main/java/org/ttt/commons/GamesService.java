package org.ttt.commons;

import static java.nio.charset.StandardCharsets.UTF_8;
import static software.amazon.awssdk.enhanced.dynamodb.internal.AttributeValues.numberValue;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.*;
import lombok.SneakyThrows;
import org.ttt.commons.exceptions.TooManyActiveGamesException;
import software.amazon.awssdk.enhanced.dynamodb.*;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AtomicCounterExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.model.Page;
import software.amazon.awssdk.enhanced.dynamodb.model.QueryConditional;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactUpdateItemEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.CancellationReason;
import software.amazon.awssdk.services.dynamodb.model.TransactionCanceledException;

public class GamesService {
  private static final String CONDITIONAL_CHECK_FAILED = "ConditionalCheckFailed";
  private final DynamoDbTable<Game> gamesTable;
  private final DynamoDbTable<GameCount> gamesCountTable;
  private final DynamoDbIndex<Game> gamesTableByPlayerId;
  private final DynamoDbIndex<Game> gamesTableByOpponentId;
  private final DynamoDbEnhancedClient enhancedClient;
  private final int maxGamesCount;
  private final Random random = new Random();
  private final ObjectMapper objectMapper = ObjectMapperFactory.create();

  public GamesService(ParametersProvider parametersProvider, DynamoDbClient dynamoDbClient) {
    DynamoDbEnhancedClient client =
        DynamoDbEnhancedClient.builder()
            .dynamoDbClient(dynamoDbClient)
            .extensions(
                AutoGeneratedTimestampRecordExtension.create(),
                AtomicCounterExtension.builder().build())
            .build();
    this.enhancedClient = client;
    String gamesTableName = parametersProvider.getParameter("GAMES_TABLE_NAME");
    this.gamesTable = client.table(gamesTableName, TableSchema.fromClass(Game.class));
    String gamesCountTableName = parametersProvider.getParameter("GAMES_COUNT_TABLE_NAME");
    maxGamesCount = Integer.parseInt(parametersProvider.getParameter("MAX_GAMES_COUNT"));
    this.gamesTableByPlayerId = this.gamesTable.index("PlayerIdIndex");
    this.gamesTableByOpponentId = this.gamesTable.index("OpponentIdIndex");
    this.gamesCountTable =
        client.table(gamesCountTableName, TableSchema.fromClass(GameCount.class));
  }

  public GamesService() {
    this(new EnvVarParametersProvider(), DynamoDbClient.create());
  }

  public Optional<Game> getGame(String gameId) {
    return Optional.ofNullable(gamesTable.getItem(Game.builder().gameId(gameId).build()));
  }

  @SneakyThrows
  private String lastEvaluatedKeyToJson(Map<String, AttributeValue> item) {
    Map<String, String> mapped = new HashMap<>();
    item.forEach((key, value) -> mapped.put(key, value.s()));
    return objectMapper.writeValueAsString(mapped);
  }

  @SneakyThrows
  private Map<String, AttributeValue> readNextPageToken(String nextPageToken) {
    TypeReference<HashMap<String, String>> typeReference = new TypeReference<>() {};
    Map<String, String> token =
        objectMapper.readValue(Base64.getUrlDecoder().decode(nextPageToken), typeReference);
    Map<String, AttributeValue> result = new HashMap<>();
    token.forEach((key, value) -> result.put(key, AttributeValue.fromS(value)));
    return result;
  }

  public GamesListPage listGames(
      String playerId, boolean byOpponent, Integer limit, String nextPageToken) {
    Map<String, AttributeValue> startKey =
        Optional.ofNullable(nextPageToken).map(this::readNextPageToken).orElse(null);
    DynamoDbIndex<Game> index = byOpponent ? gamesTableByOpponentId : gamesTableByPlayerId;
    Page<Game> page =
        index
            .query(
                request ->
                    request
                        .queryConditional(
                            QueryConditional.keyEqualTo(key -> key.partitionValue(playerId)))
                        .exclusiveStartKey(startKey)
                        .limit(limit))
            .stream()
            .findFirst()
            .orElseThrow();
    String newNextPageToken =
        Optional.ofNullable(page.lastEvaluatedKey())
            .map(this::lastEvaluatedKeyToJson)
            .map(json -> new String(Base64.getUrlEncoder().encode(json.getBytes()), UTF_8))
            .orElse(null);
    return new GamesListPage(page.items(), newNextPageToken);
  }

  private Map<String, GameSymbol> mapGameSymbols(String playerId, String opponentId) {
    int playerSymbolIndex = random.nextInt(0, 2);
    int opponentSymbolIndex = (playerSymbolIndex + 1) % 2;
    GameSymbol[] values = GameSymbol.values();
    return Map.of(
        playerId, values[playerSymbolIndex],
        opponentId, values[opponentSymbolIndex]);
  }

  public Game createNewGame(CreateGameRequest request) {
    UUID uuid = UUID.randomUUID();
    Game game =
        Game.builder()
            .state(GameState.ACTIVE)
            .gameId(uuid.toString())
            .playerId(request.hostPlayerId())
            .opponentId(request.opponentId())
            .symbolMapping(mapGameSymbols(request.hostPlayerId(), request.opponentId()))
            .build();
    GameCount gameCount = GameCount.builder().playerId(request.hostPlayerId()).build();
    try {
      enhancedClient.transactWriteItems(
          TransactWriteItemsEnhancedRequest.builder()
              .addPutItem(gamesTable, game)
              .addUpdateItem(
                  gamesCountTable,
                  TransactUpdateItemEnhancedRequest.builder(GameCount.class)
                      .item(gameCount)
                      .conditionExpression(
                          Expression.builder()
                              // This checks existing value before atomic increment, then performs
                              // the
                              // update
                              .expression(
                                  "attribute_not_exists(activeGames) OR activeGames < :limit")
                              .putExpressionValue(":limit", numberValue(maxGamesCount))
                              .build())
                      .build())
              .build());
    } catch (TransactionCanceledException exception) {
      if (exception.cancellationReasons().stream()
          .map(CancellationReason::code)
          .anyMatch(code -> code.equals(CONDITIONAL_CHECK_FAILED))) {
        throw new TooManyActiveGamesException(
            "Maximum number of active games reached, finish your games first");
      }
      throw exception;
    }
    return gamesTable.getItem(Key.builder().partitionValue(uuid.toString()).build());
  }
}
