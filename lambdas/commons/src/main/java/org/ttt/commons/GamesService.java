package org.ttt.commons;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.ttt.commons.GameState.FINISHED;
import static software.amazon.awssdk.enhanced.dynamodb.internal.AttributeValues.numberValue;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.IntStream;
import lombok.SneakyThrows;
import org.ttt.commons.exceptions.*;
import software.amazon.awssdk.enhanced.dynamodb.*;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AtomicCounterExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.model.Page;
import software.amazon.awssdk.enhanced.dynamodb.model.QueryConditional;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactUpdateItemEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.CancellationReason;
import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;
import software.amazon.awssdk.services.dynamodb.model.TransactionCanceledException;

public class GamesService {
  private static final String CONDITIONAL_CHECK_FAILED = "ConditionalCheckFailed";
  private final DynamoDbTable<Game> gamesTable;
  private final DynamoDbTable<GameCount> gamesCountTable;
  private final DynamoDbIndex<Game> gamesTableByPlayerId;
  private final DynamoDbIndex<Game> gamesTableByOpponentId;
  private final DynamoDbEnhancedClient enhancedClient;
  private final int maxGamesCount;
  private final GameSymbolMapper gameSymbolMapper;
  private final ObjectMapper objectMapper = ObjectMapperFactory.create();

  public GamesService(
      ParametersProvider parametersProvider,
      DynamoDbClient dynamoDbClient,
      GameSymbolMapper gameSymbolMapper) {
    DynamoDbEnhancedClient client =
        DynamoDbEnhancedClient.builder()
            .dynamoDbClient(dynamoDbClient)
            .extensions(
                AutoGeneratedTimestampRecordExtension.create(),
                AtomicCounterExtension.builder().build())
            .build();
    this.enhancedClient = client;
    String gamesTableName = parametersProvider.getParameter("GAMES_TABLE_NAME");
    this.gamesTable = client.table(gamesTableName, TableSchema.fromClass(Game.class));
    String gamesCountTableName = parametersProvider.getParameter("GAMES_COUNT_TABLE_NAME");
    maxGamesCount = Integer.parseInt(parametersProvider.getParameter("MAX_GAMES_COUNT"));
    this.gamesTableByPlayerId = this.gamesTable.index("PlayerIdIndex");
    this.gamesTableByOpponentId = this.gamesTable.index("OpponentIdIndex");
    this.gameSymbolMapper = gameSymbolMapper;
    this.gamesCountTable =
        client.table(gamesCountTableName, TableSchema.fromClass(GameCount.class));
  }

  public GamesService() {
    this(new EnvVarParametersProvider(), DynamoDbClient.create(), new RandomGameSymbolMapper());
  }

  public Optional<Game> getGame(String gameId) {
    return Optional.ofNullable(gamesTable.getItem(Game.builder().gameId(gameId).build()));
  }

  @SneakyThrows
  private String lastEvaluatedKeyToJson(Map<String, AttributeValue> item) {
    Map<String, String> mapped = new HashMap<>();
    item.forEach((key, value) -> mapped.put(key, value.s()));
    return objectMapper.writeValueAsString(mapped);
  }

  @SneakyThrows
  private Map<String, AttributeValue> readNextPageToken(String nextPageToken) {
    TypeReference<HashMap<String, String>> typeReference = new TypeReference<>() {};
    Map<String, String> token =
        objectMapper.readValue(Base64.getUrlDecoder().decode(nextPageToken), typeReference);
    Map<String, AttributeValue> result = new HashMap<>();
    token.forEach((key, value) -> result.put(key, AttributeValue.fromS(value)));
    return result;
  }

  private boolean symbolsEqual(GameSymbol first, GameSymbol second) {
    if (first == null || second == null) {
      return false;
    }
    return first == second;
  }

  private boolean checkLine(GameSymbol[][] symbols, int line) {
    return symbolsEqual(symbols[0][line], symbols[1][line])
        && symbolsEqual(symbols[0][line], symbols[2][line]);
  }

  private boolean checkColumn(GameSymbol[][] symbols, int column) {
    return symbolsEqual(symbols[column][0], symbols[column][1])
        && symbolsEqual(symbols[column][0], symbols[column][2]);
  }

  private boolean checkCross(GameSymbol[][] symbols) {
    return (symbolsEqual(symbols[0][0], symbols[1][1])
            && symbolsEqual(symbols[0][0], symbols[2][2]))
        || (symbolsEqual(symbols[0][2], symbols[1][1])
            && symbolsEqual(symbols[0][2], symbols[2][0]));
  }

  private boolean check(IntFunction<Boolean> function) {
    return IntStream.range(0, 3).mapToObj(function).anyMatch(Boolean::booleanValue);
  }

  private boolean hasPlayerWon(Game game) {
    GameSymbol[][] symbols = new GameSymbol[3][3];
    game.getMoves().forEach(move -> symbols[move.getX()][move.getY()] = move.getSymbol());
    return checkCross(symbols)
        || check(i -> checkLine(symbols, i))
        || check(i -> checkColumn(symbols, i));
  }

  public void commitMove(String gameId, String playerId, CommitMoveRequest request)
      throws GameNotFoundException,
          GameAlreadyFinishedException,
          WrongSymbolException,
          GameRoundDoesNotMatch,
          NotYourTurnException,
          PositionAlreadyOccupiedException,
          BadRequestException {
    Game game =
        getGame(gameId)
            .orElseThrow(
                () ->
                    new GameNotFoundException(String.format("Game with ID %s not found", gameId)));
    if (request.positionX() > 2 || request.positionY() > 2) {
      throw new BadRequestException("Position should be in range [0,2]");
    }
    if (game.getState() == FINISHED) {
      throw new GameAlreadyFinishedException(
          String.format("Game with ID %s already finished", game));
    }
    GameSymbol expectedSymbol = game.getSymbolMapping().get(playerId);
    if (expectedSymbol != request.symbol()) {
      throw new WrongSymbolException(
          String.format(
              "Symbol %s expected, received %s instead", expectedSymbol, request.symbol()));
    }
    if (!request.round().equals(game.getRound().intValue())) {
      throw new GameRoundDoesNotMatch(
          String.format("Round number %d not expected", request.round()));
    }
    if (!playerId.equals(game.getCurrentPlayerId())) {
      throw new NotYourTurnException("Not your turn");
    }
    boolean isPositionOccupied =
        game.getMoves().stream()
            .anyMatch(
                move ->
                    move.getX().equals(request.positionX())
                        && move.getY().equals(request.positionY()));
    if (isPositionOccupied) {
      throw new PositionAlreadyOccupiedException(
          String.format(
              "Position (%d,%d) already occupied", request.positionX(), request.positionY()));
    }
    List<GameMove> moves = new ArrayList<>(game.getMoves());
    moves.add(new GameMove(request.positionX(), request.positionY(), request.symbol()));
    String nextPlayerId =
        game.getPlayerId().equals(playerId) ? game.getOpponentId() : game.getPlayerId();
    Game updatedGame = game.withMoves(moves).withCurrentPlayerId(nextPlayerId);
    final Game gameToSave =
        hasPlayerWon(updatedGame)
            ? updatedGame.withState(FINISHED).withWinnerId(playerId)
            : updatedGame;
    try {
      gamesTable.updateItem(
          b ->
              b.item(gameToSave)
                  .conditionExpression(
                      Expression.builder()
                          .expression("round = :expected")
                          .putExpressionValue(":expected", numberValue(gameToSave.getRound()))
                          .build()));
    } catch (ConditionalCheckFailedException e) {
      throw new GameRoundDoesNotMatch(
          String.format("Round number %d not expected", game.getRound()));
    }
  }

  public GamesListPage listGames(
      String playerId, boolean byOpponent, Integer limit, String nextPageToken) {
    Map<String, AttributeValue> startKey =
        Optional.ofNullable(nextPageToken).map(this::readNextPageToken).orElse(null);
    DynamoDbIndex<Game> index = byOpponent ? gamesTableByOpponentId : gamesTableByPlayerId;
    Page<Game> page =
        index
            .query(
                request ->
                    request
                        .queryConditional(
                            QueryConditional.keyEqualTo(key -> key.partitionValue(playerId)))
                        .exclusiveStartKey(startKey)
                        .limit(limit))
            .stream()
            .findFirst()
            .orElseThrow();
    String newNextPageToken =
        Optional.ofNullable(page.lastEvaluatedKey())
            .map(this::lastEvaluatedKeyToJson)
            .map(json -> new String(Base64.getUrlEncoder().encode(json.getBytes()), UTF_8))
            .orElse(null);
    return new GamesListPage(page.items(), newNextPageToken);
  }

  public Game createNewGame(CreateGameRequest request) throws TooManyActiveGamesException {
    UUID uuid = UUID.randomUUID();
    String hostId = request.hostPlayerId();
    String opponentId = request.opponentId();
    Map<String, GameSymbol> playerToSymbol = gameSymbolMapper.mapGameSymbols(hostId, opponentId);
    String currentPlayerId = playerToSymbol.get(hostId) == GameSymbol.CROSS ? hostId : opponentId;
    Game game =
        Game.builder()
            .state(GameState.ACTIVE)
            .gameId(uuid.toString())
            .playerId(hostId)
            .opponentId(opponentId)
            .moves(List.of())
            .currentPlayerId(currentPlayerId)
            .symbolMapping(playerToSymbol)
            .build();
    GameCount gameCount = GameCount.builder().playerId(request.hostPlayerId()).build();
    try {
      enhancedClient.transactWriteItems(
          TransactWriteItemsEnhancedRequest.builder()
              .addPutItem(gamesTable, game)
              .addUpdateItem(
                  gamesCountTable,
                  TransactUpdateItemEnhancedRequest.builder(GameCount.class)
                      .item(gameCount)
                      .conditionExpression(
                          Expression.builder()
                              // This checks existing value before atomic increment, then performs
                              // the
                              // update
                              .expression(
                                  "attribute_not_exists(activeGames) OR activeGames < :limit")
                              .putExpressionValue(":limit", numberValue(maxGamesCount))
                              .build())
                      .build())
              .build());
    } catch (TransactionCanceledException exception) {
      if (exception.cancellationReasons().stream()
          .map(CancellationReason::code)
          .anyMatch(code -> code.equals(CONDITIONAL_CHECK_FAILED))) {
        throw new TooManyActiveGamesException(
            "Maximum number of active games reached, finish your games first");
      }
      throw exception;
    }
    return gamesTable.getItem(Key.builder().partitionValue(uuid.toString()).build());
  }
}
